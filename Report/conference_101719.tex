\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{listings}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Formal Verification of Integer Multiplier Circuits\\}

\author{
\IEEEauthorblockN{Jonathan Wang}
\IEEEauthorblockA{\textit{Price College of Engineering} \\
\textit{University of Utah}\\
Salt Lake City, Utah \\
u1306458@utah.edu}
\and
\IEEEauthorblockN{Henry Silverman}
\IEEEauthorblockA{\textit{Price College of Engineering} \\
\textit{University of Utah}\\
Salt Lake City, Utah \\
henry.silverman@utah.edu}
\and
\IEEEauthorblockN{Garrett Slack}
\IEEEauthorblockA{\textit{Price College of Engineering} \\
\textit{University of Utah}\\
Salt Lake City, Utah \\
u1315263@utah.edu}
\and
\IEEEauthorblockN{Dmitry Panin}
\IEEEauthorblockA{\textit{Price College of Engineering} \\
\textit{University of Utah}\\
Salt Lake City, Utah \\
dmitry.panin@utah.edu}
}

\maketitle

\begin{abstract}
This paper employs advanced mathematical techniques, specifically polynomials, and ideals, 
to rigorously verify the correctness of an integer multiplier circuit. By leveraging algebraic methods, 
this approach will provide a deeper understanding of the circuit's behavior and enable a more robust 
verification process. 
\end{abstract}

\begin{IEEEkeywords}
polynomials, ideals, multiplier circuit
\end{IEEEkeywords}

\section{Introduction}
In the field of digital circuit design, integer multiplier circuits stand as fundamental components with critical applications in various computing 
systems, ranging from embedded devices to high-performance computing architectures. The accurate and efficient operation of these multiplier 
circuits is crucial for ensuring the reliability and correctness of arithmetic computations. As technology advances and design complexities 
escalate, the need for rigorous verification methodologies has become increasingly pronounced to guarantee the integrity of digital circuits. Our 
project tests and verifies an these integer multiplier circuits by employing the various methods studied in class on smaller circuits and circuits over
fields.

\section{Approach}
Ideal membership testing is a great method to test and verify of a 2-bit, 3-bit, 16-bit, and 32-bit integer multiplier circuit.
We manually designed the 2-bit and 3-bit multiplier from scratch and generated the larger circuits utilizing the ABC synthesis tool. Next we
convert the blif files to sing files using our parsing python script. Then derived the RTTO (Reverse Topological Term Order) from the circuit, and used it to
represent the minimal Gröbner Basis. The circuit is verified if the Gröbner Basis of $J$ + $J_{0}$ equals 0.

\section{Process}
% the algorithms or techniques that you have studied, and you should demonstrate parts of your main contribution/study using example circuits, designs or code fragments
\subsection{Singular}
The Singular file consists of a ring, polynomials, ideals, and other code to help interpret the output. A ring is defined by their properties, 
including the type of coefficients, the number and names of variables, and the arithmetic operations. The order of the inputs and outputs in 
the ring R should be outputs, internal gate outputs, and inputs. A poly represents the algebraic representation of logic gate in the circuit. 
For example, $f_{spec}$ represents the desired mathematical functionality of the implemented circuit. Ideals are subset of the polynomial ring 
that consists of all polynomials that satisfy certain conditions. Below is the pseudo code for an integer arithmetic circuit.
\begin{algorithm}
    \caption{Example Singular code for arithmetic circuit}
    \begin{algorithmic}
        \STATE // Declare ring
        \STATE ring R = 0, (outputs, internal outputs, inputs), lp;
        \STATE
        \STATE // Declare $f_{spec}$ and polys of internal gates
        \STATE poly $f_{spec}$ = equations of circuit;
        \STATE poly $f_{4}$ = $z_{0}$ - $s_{0}$ - $e_{0}$ + 2*$s_{0}$*$e_{0}$; 
        \STATE Continue to model logic gates over Q
        \STATE
        \STATE // Declare ideals
        \STATE ideal J = f4, f5,  f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16;
        \STATE ideal J0 = vanishing polynomials;
        \STATE
        \STATE Use groebner($J$ + $J_{0}$) to find the Gröbner Basis
        \STATE
        \STATE Use NF($f_{spec}$, $J$ + $J_{0}$, 1); for membership test
    \end{algorithmic}
\end{algorithm}

\section{Algorithms and Techniques}
Techniques for ideal membership testing: 
\begin{enumerate}
    \item Setup the verification formulation over the polynomial ring R. 
    \item Declare a specification polynomial from the circuit $f_{spec}$.
    \item Derive the polynomials from the gates of the circuit \{$f_{1}$, ..., $f_{s}$\}. 
    \item Set ideal J = $f_{1}$, ...,$f_{s}$.     % what is J0 in our case? 
    \item Create the ideal of vanishing polynomials for each variable J0 = 
    \item Take the Gröbner Basis: G = GB(J + $J_{0}$).  
    \item The circuit implements \(f_{\text{spec}}\) \(\Longleftrightarrow\) \(f_{\text{spec}} \in (J + J_0)\) if and only if \(f_{\text{spec}}\)
    is divisible by G
\end{enumerate}
The steps to run Singular, ABC, and the Python script are in the README. 

\section{Software implementations} % needs to fix pseudocode cuz it doesnt work 
We implemented a Python function with assistance from ChatGPT to convert blif files to sing files. The code defines a gate mapping dictionary that maps gate types 
from the blif file to their corresponding names in Singular. It iterates through and searches for lines starting with '.gate' and extracts the gate type and its 
inputs, parsing and separating them accordingly into the Singular file. Additionally, we added code for error handling because the Singular file was empty when 
experimenting. 
\begin{algorithm}
    \caption{Convert BLIF to Singular}
    \begin{algorithmic}
        \IF{content exists}
            \STATE map gates
            \FOR{each line in blif file}
                \IF{line starts with ".gate"}
                    \STATE gate\_type, gate\_inputs $\gets$ parse line
                    \IF{gate\_type EXISTS IN gate\_map}
                        \STATE Generate Singular code based on gate\_type and gate\_inputs
                    \ENDIF
                \ENDIF
            \ENDFOR
            \IF{singular\_code is NOT EMPTY}
                \STATE write singular\_code TO output\_file\_path
                \STATE print "Singular code written to output\_file\_path"
            \ELSE
                \STATE print "No valid Singular code generated. Check the BLIF file content."
            \ENDIF
        \ELSE
            \STATE print "File 'file\_path' not found."
        \ENDIF
        \STATE \textbf{end function}
    \end{algorithmic}
    \end{algorithm}

\section{Concepts learned}
\subsection{Mathematical Ideals}
Ideals ensure the accuracy of electronic systems In circuit testing and verification. 
Ideal membership testing involves using mathematical 
models to assess whether a circuit aligns with specified ideal characteristics. 
Engineers compare these models with real-world circuit implementations to identify 
discrepancies to help detect potential faults in the design. This approach enhances 
precision and provides a systematic framework for validating complex circuits, 
contributing to the development of high-quality electronic systems.

\subsection{Gröbner Basis}
Gröbner Basis in-circuit testing and verification is a powerful method that 
involves algebraic techniques to analyze and validate complex electronic systems. 
Gröbner Bases provide a systematic way to address polynomial equations representing 
circuit behaviors. Gröbner Bases are a fundamental concept in algebraic geometry and 
computer algebra systems, and they play a crucial role in solving systems of polynomial 
equations. The primary idea behind Gröbner Bases is to provide a systematic method for 
transforming a set of polynomials into a more manageable and structured form.

\subsection{blif to sing conversion}
By using a python script to parse our mapped blif files (lib2.genlib), we 
can convert the list of gates contained in the blif file to a list of 
corresponding polynomials for our sing file. By splitting the blif file line by line and
parsing for key words such as ".gate," "XOR," "NAND," and "INV" to create the different
polynomial equations to model logic gates over Q. For example, "XOR" uses 
the equation z - a - b + 2ab, and "AND" uses the equation z = a * b for the 
corresponding polynomials. Python makes this very easy with its parsing functionalities. 

\subsection{Ideal Membership Testing}
Ideal membership testing is a mathematical approach used in circuit verification to 
determine whether a given circuit satisfies ideal properties or conditions. 
It involves algebraic structures known as ideals, particularly in the 
context of polynomial rings. An ideal is a subset of the polynomial ring that consists 
of all polynomials that satisfy certain conditions. In the context of circuit 
verification, the ideal encapsulates the set of polynomials representing the 
desired ideal behavior of the circuit. The core of the process involves determining 
whether a given polynomial, representing the behavior of the actual circuit, belongs 
to the ideal. If the polynomial is an element of the ideal, it indicates that the circuit 
satisfies the ideal properties. Otherwise, it suggests a deviation from the expected behavior.

\subsection{Miters}
Miters play a crucial role in circuit testing and verification. A model of the circuit is integrated into 
the testing process, allowing for comprehensive analysis. The miter compares the expected behavior with 
the actual circuit response using an xor gate to highlighting any discrepancies based on the model. 
By using miters, we can identify and address potential issues before moving to further stages of development 
or production, ensuring that the circuit functions as intended.  

\section{Labour Division}
\begin{itemize}
    \item Jonathan: Generated the blif files and converted it to Singular files and wrote the report
    \item Henry: Debugged Python Code 
    \item Garrett: Help write the report
    \item Dmitri: Provided Singular code for 2-bit,3-bit and 4-bit multipliers and visuals
\end{itemize}

\begin{thebibliography}{03}
\bibitem{b1} D. Ritirc, A. Biere and M. Kauers, "Column-wise verification of multipliers using computer algebra," 2017 Formal Methods in Computer Aided Design (FMCAD), Vienna, Austria, 2017, pp. 23-30, doi: 10.23919/FMCAD.2017.8102237.
\bibitem{b2} T. Pruss, P. Kalla and F. Enescu, "Efficient Symbolic Computation for Word-Level Abstraction From Combinational Circuits for Verification Over Finite Fields," in IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 35, no. 7, pp. 1206-1218, July 2016, doi: 10.1109/TCAD.2015.2501301.
\bibitem{b3} Jerry R. Burch. 1991. Using BDDs to verify multipliers. In Proceedings of the 28th ACM/IEEE Design Automation Conference (DAC '91). Association for Computing Machinery, New York, NY, USA, 408–412. https://doi.org/10.1145/127601.127703
\end{thebibliography}
\vspace{12pt}

\end{document}
